plugins {
  id 'java-library'
  id 'maven-publish'
  id 'com.diffplug.spotless' version '6.25.0'
  id 'io.freefair.lombok' version '9.0.0-rc2'
  id 'idea'
  id 'eclipse'
}

idea {
  module {
    downloadJavadoc = true
    downloadSources = true
  }
}

eclipse {
  classpath {
    downloadSources = true
    downloadJavadoc = true
  }
}

version = generateVersion() // we could cache but not worth the hassle
group = 'dev.braintrust'

java {
  toolchain {
    languageVersion = JavaLanguageVersion.of(17)
    vendor = JvmVendorSpec.ADOPTIUM // eclipse JVM
  }
  withJavadocJar()
  withSourcesJar()
}

tasks.withType(JavaCompile).configureEach {
  options.release = 17
}

repositories {
  mavenCentral()
}

ext {
  otelVersion = '1.54.1'
  jacksonVersion = '2.16.1'
  junitVersion = '5.11.4'
  slf4jVersion = '2.0.17'
}

dependencies {
  api "io.opentelemetry:opentelemetry-api:${otelVersion}"
  api "io.opentelemetry:opentelemetry-sdk:${otelVersion}"
  api "io.opentelemetry:opentelemetry-sdk-trace:${otelVersion}"
  api "io.opentelemetry:opentelemetry-sdk-logs:${otelVersion}"
  implementation "io.opentelemetry:opentelemetry-exporter-otlp:${otelVersion}"
  implementation "io.opentelemetry:opentelemetry-exporter-logging:${otelVersion}"
  implementation "io.opentelemetry:opentelemetry-semconv:1.30.1-alpha"

  implementation "com.fasterxml.jackson.core:jackson-databind:${jacksonVersion}"
  implementation "com.fasterxml.jackson.datatype:jackson-datatype-jsr310:${jacksonVersion}"
  implementation "com.fasterxml.jackson.datatype:jackson-datatype-jdk8:${jacksonVersion}"

  implementation "org.slf4j:slf4j-api:${slf4jVersion}"

  implementation 'org.apache.commons:commons-lang3:3.14.0'
  implementation 'com.google.code.findbugs:jsr305:3.0.2' // for @Nullable annotations

  testImplementation "org.slf4j:slf4j-simple:${slf4jVersion}"
  testImplementation "io.opentelemetry:opentelemetry-sdk-testing:${otelVersion}"
  testImplementation "org.junit.jupiter:junit-jupiter:${junitVersion}"
  testImplementation "org.junit.jupiter:junit-jupiter-params:${junitVersion}"
  testImplementation 'com.github.tomakehurst:wiremock-jre8:2.35.0'

  // OAI instrumentation
  compileOnly 'com.openai:openai-java:2.8.1'
  testImplementation 'com.openai:openai-java:2.8.1'
  implementation "io.opentelemetry.instrumentation:opentelemetry-openai-java-1.1:2.19.0-alpha"

  // Anthropic Instrumentation
  compileOnly "com.anthropic:anthropic-java:2.8.1"
  testImplementation "com.anthropic:anthropic-java:2.8.1"
}

/**
 * Use git to compute the sdk version
 *
 * This is written into braintrust.properties at build time and shipped into the distributed sdk jar
 *
 * - if we are on a tag (i.e. v0.0.3), use the tag
 * - otherwise, use $mostRecentTag-$currentCommitSha
 *
 * Additionally, if the git workspace is not clean, append -DIRTY to the version
 *
 * Examples
 * - v0.0.3
 * - v0.0.3-c4af682
 * - v0.0.3-c4af682-DIRTY
 */
def generateVersion() {
  // Check if workspace is clean
  def gitStatusProcess = ['git', 'status', '--porcelain'].execute()
  gitStatusProcess.waitFor()
  def gitStatus = gitStatusProcess.text.trim()
  def isDirty = !gitStatus.isEmpty()

  // Get current commit SHA (short version)
  def gitShaProcess = ['git', 'rev-parse', '--short', 'HEAD'].execute()
  gitShaProcess.waitFor()
  def gitSha = gitShaProcess.text.trim()

  // Check if we're currently on a tag
  def currentTag = null
  try {
    def currentTagProcess = ['git', 'describe', '--exact-match', '--tags', 'HEAD'].execute()
    currentTagProcess.waitFor()
    if (currentTagProcess.exitValue() == 0) {
      currentTag = currentTagProcess.text.trim()
    }
  } catch (Exception e) {
    // Not on a tag, that's fine
  }

  def version
  if (currentTag != null) {
    // We're on a tag, use the tag name
    version = currentTag
  } else {
    // Not on a tag, find the most recent tag
    def mostRecentTag = null
    try {
      def mostRecentTagProcess = ['git', 'describe', '--tags', '--abbrev=0'].execute()
      mostRecentTagProcess.waitFor()
      if (mostRecentTagProcess.exitValue() == 0) {
        mostRecentTag = mostRecentTagProcess.text.trim()
      }
    } catch (Exception e) {
      // No tags found, use just the SHA
      mostRecentTag = null
    }

    if (mostRecentTag != null) {
      version = "${mostRecentTag}-${gitSha}"
    } else {
      version = gitSha
    }
  }

  // Append -DIRTY if workspace is not clean
  if (isDirty) {
    version = "${version}-DIRTY"
  }

  return version
}

// Generate braintrust.properties at build time with smart versioning
task generateBraintrustProperties {
  description = 'Generate braintrust.properties with smart git-based versioning'
  group = 'build'

  def outputDir = layout.buildDirectory.dir("generated/resources").get().asFile
  def outputFile = new File(outputDir, "braintrust.properties")

  // Tell Gradle what affects this task so it can cache properly
  inputs.property("gitSha", {
    ['git', 'rev-parse', 'HEAD'].execute().text.trim()
  })
  inputs.property("gitStatus", {
    ['git', 'status', '--porcelain'].execute().text.trim()
  })

  outputs.file outputFile

  doLast {
    outputDir.mkdirs()

    def version = generateVersion()

    outputFile.text = "sdk.version=${version}\n"

    logger.info("Generated braintrust.properties with sdk.version=${version}")
  }
}

test {
  dependsOn generateBraintrustProperties
  useJUnitPlatform()
  testLogging {
    events "passed", "skipped", "failed"
    exceptionFormat "full"
  }
  environment 'TEST_VAR1', 'fromenv1'
  environment 'TEST_VAR2', 'fromenv2'

  doFirst {
    // Set the version at execution time, after properties are generated
    environment 'GRADLE_SDK_VERSION', version
  }
}

// Enable preview features for pattern matching, etc.
// Commented out for Java 24 compatibility
// tasks.withType(JavaCompile) {
//     options.compilerArgs += ["--enable-preview"]
// }

// tasks.withType(Test) {
//     jvmArgs += ["--enable-preview"]
// }

// tasks.withType(JavaExec) {
//     jvmArgs += ["--enable-preview"]
// }

jar {
  manifest {
    attributes(
      'Implementation-Title': 'Braintrust Java SDK',
      'Implementation-Version': version,
      'Implementation-Vendor': 'Braintrust',
      'Main-Class': 'dev.braintrust.trace.SDKMain'
    )
  }
}

publishing {
  publications {
    maven(MavenPublication) {
      from components.java

      pom {
        name = 'Braintrust Java SDK'
        description = 'OpenTelemetry-based Braintrust SDK for Java'
        url = 'https://github.com/braintrustdata/braintrust-x-java'

        licenses {
          license {
            name = 'MIT License'
            url = 'https://opensource.org/licenses/MIT'
          }
        }

        developers {
          developer {
            id = 'braintrust'
            name = 'Braintrust Team'
            email = 'support@braintrust.dev'
          }
        }
      }
    }
  }
}


// Include generated resources in the JAR
sourceSets {
  main {
    resources {
      srcDir layout.buildDirectory.dir("generated/resources")
    }
  }
}

// Make sure properties are generated before compilation and packaging
compileJava.dependsOn generateBraintrustProperties
processResources.dependsOn generateBraintrustProperties
sourcesJar.dependsOn generateBraintrustProperties
jar.dependsOn generateBraintrustProperties

// Configure Spotless for code formatting
spotless {
  java {
    target 'src/*/java/**/*.java', 'examples/src/*/java/**/*.java'

    // Use Google Java Format
    googleJavaFormat('1.19.2').aosp().reflowLongStrings()

    // Remove unused imports
    removeUnusedImports()

    // Trim trailing whitespace
    trimTrailingWhitespace()

    // End with newline
    endWithNewline()
  }
}

task validateJavaVersion {
  doLast {
    def currentVersion = JavaVersion.current()
    def requiredVersion = JavaVersion.VERSION_17

    if (!currentVersion.isCompatibleWith(requiredVersion)) {
      throw new GradleException(
        "This project requires Java ${requiredVersion} or later. " +
        "Current Java version: ${currentVersion} " +
        "(${System.getProperty('java.version')}) " +
        "from ${System.getProperty('java.home')}"
      )
    }
    // println "✓ Using Java ${currentVersion} from ${System.getProperty('java.home')}"
  }
}


// Task to test the jar by running it
task testJar(type: JavaExec) {
  description = 'Test the jar by running it and fail build if non-zero exit code'
  group = 'verification'
  dependsOn jar

  classpath = files(jar.archiveFile)
  javaLauncher = javaToolchains.launcherFor(java.toolchain)

  // Capture standard output
  standardOutput = new ByteArrayOutputStream()

  doFirst {
    // println "Testing jar: ${jar.archiveFile.get().asFile.absolutePath}"
  }

  doLast {
    // Get the version printed by the jar
    def printedVersion = standardOutput.toString().trim()

    // Get the expected version from git state
    def expectedVersion = generateVersion()

    // Compare versions
    if (printedVersion != expectedVersion) {
      throw new GradleException(
        "Version mismatch! Jar printed version '${printedVersion}' " +
        "but expected version from git state is '${expectedVersion}'"
      )
    }

    logger.lifecycle("✓ Jar version validation passed: ${printedVersion}")
  }
}

// Run validation before compilation
compileJava.dependsOn validateJavaVersion

// Run jar test as part of check task
check.dependsOn testJar

// Task to install git hooks
task installGitHooks(type: Exec) {
  description = 'Install git hooks for code formatting'
  group = 'Build Setup'
  commandLine 'bash', 'scripts/install-hooks.sh'
}
